package it.emarolab.scene_identification_tracking.semanticSceneLibrary;

import it.emarolab.scene_identification_tracking.semanticSceneLibrary.Logger.SITBase;
import it.emarolab.scene_identification_tracking.semanticSceneLibrary.aMORDescriptor.MOR3DArray;
import it.emarolab.scene_identification_tracking.semanticSceneLibrary.objects.ObjectSemantics;
import org.semanticweb.owlapi.model.OWLClass;

import java.util.List;
import java.util.Set;

/**
 * General interface to define the mapping between
 * an object and the semantics structure.
 * <p>
 * An implementation example (based on aMOR library)
 * of this interface is available in the package:
 * {@link it.emarolab.scene_identification_tracking.semanticSceneLibrary.objects.aMOR}
 * <p>
 * <b>REMARK</b>: the unity of measure of the geometric quantities
 * defined in this interface depends on how its implementation is instantiated.<br>
 * Good practice is to use the International System of Units (e.g.: meters)
 *
 * <div style="text-align:center;"><small>
 * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
 * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
 * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
 * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
 * <b>date</b>:       06/01/2017 <br>
 * </small></div>
 *
 * @see IndividualDescriptor.DataDescriptor
 * @see ObjectSemantics.Primitive
 * @see ObjectSemantics.Orientable
 * @see ObjectSemantics.Sphere
 * @see ObjectSemantics.Plane
 * @see ObjectSemantics.Cone
 * @see ObjectSemantics.Cylinder
 * @see MappingState
 * @see WritingState
 * @see ReadingState
 * @see ReadingOutcome
 * @see MappingTry
 * @see TryingWrite
 * @see TryingRead
 * @see it.emarolab.scene_identification_tracking.semanticSceneLibrary.Logger.SITBase
 * @see SITBase.SITBase
 */
public interface Semantics {

    /**
     * Writes the object characteristics in the semantic structure (map to semantics).
     * @return the state of the writing process.
     */
    WritingState writeSemantics();
    /**
     * Reads the object characteristics from the semantic structure (map from semantics).
     * @return the state of the reading process.
     */
    ReadingState readSemantics();

    /**
     * This class implements the possible common states
     * between reading ({@link ReadingState}) and writing ({@link WritingState})
     * to/from semantic operation.
     * <p>In particular, this class manages the states:<ul>
     *    <li> <b>ERROR</b>: java error occurs while mapping semantics,
     *    <li> <b>INCONSISTENT</b>: generated by the semantic reasoner,
     *    <li> <b>NOT CHANGED</b>: the mapping between semantics and java-structures is up to dated.
     *                      This operation did not produced any changes.
     * </ul>
     *
     * <p>
     * <b>REMARK</b>: extending classes must have static state fields
     * assigned to inter values bigger than {@link #NOT_CHANGED}.
     *
     * <div style="text-align:center;"><small>
     * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
     * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
     * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
     * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
     * <b>date</b>:       06/01/2017 <br>
     * </small></div>
     *
     * @see WritingState
     * @see ReadingState
     * @see ReadingOutcome
     * @see MappingTry
     * @see TryingWrite
     * @see TryingRead
     */
    abstract class MappingState extends SITBase.SITBase {
        /** The identifier for the ERROR state. */
        static public final int ERROR = -1; // error on java code
        /** The identifier for the INCONSISTENT state. */
        static public final int INCONSISTENT = 0; // inconsistent ontology or state state
        /** The identifier for the NOT_CHANGED (up to dated) state. */
        static public final int NOT_CHANGED = 1; // reading or writing did not produce ant changes
        // if you change this enumerator remember to change on extending class (construcing validation problems)

        /**
         * The internal state of this instance.
         * It can be: {@link #ERROR}, {@link #INCONSISTENT} or {@link #NOT_CHANGED}.
         */
        protected int state;

        /** Empty constructor, initialises this {@link #state} {@link #asInconsistent()}. */
        public MappingState() {
            asInconsistent();
        }

        /**
         * Constructs this object with a given state.<br>
         * The input parameter must be:
         * <code> {@link #state} &gt;= {@link #ERROR} &amp; {@link #state} &lt;= {@link #NOT_CHANGED} </code>.
         * Otherwise, the {@link #state} will be set {@link #asInconsistent()}.
         * @param state the outcome of a semantic mapping (read/write) operation.
         */
        public MappingState(int state) {
            if (state >= ERROR & state <= NOT_CHANGED)
                this.state = state;
            else asInconsistent();
        }

        /** @return the {@link #state} assigned to this semantic mapping operation. */
        public int getState() {
            return state;
        }

        /**
         * set this state as {@link #ERROR}
         * @return <code>'this'</code>, for chaining calls.
         */
        public MappingState asError() {
            this.state = ERROR;
            return this;
        }

        /**
         * set this state as {@link #NOT_CHANGED}
         * @return <code>'this'</code>, for chaining calls.
         */
        public MappingState asNotChanged() {
            this.state = NOT_CHANGED;
            return this;
        }

        /**
         * set this state as {@link #INCONSISTENT}
         * @return <code>'this'</code>, for chaining calls.
         */
        public MappingState asInconsistent() {
            this.state = INCONSISTENT;
            return this;
        }

        /**
         * @return <code>true</code> if <code>{@link #state} &gt; 0</code>.
         * Namely, if {@link #state} is not {@link #ERROR} or {@link #INCONSISTENT}.
         */
        public boolean isOK() {
            return state > 0;
        }

        /**
         * @return <code>true</code> if this operation produces an error.
         * Namely, <code>return {@link #state} == {@link #ERROR}</code>.
         */
        public boolean isError() {
            return state == ERROR;
        }

        /**
         * @return <code>true</code> if this operation did not change nothing.
         * Namely, <code>return {@link #state} == {@link #NOT_CHANGED};</code>.
         */
        public boolean isNotChanged() {
            return state == NOT_CHANGED;
        }

        /**
         * @return <code>true</code> if this operation brings the semantic on inconsistency.
         * Namely, <code>return {@link #state} == {@link #INCONSISTENT}</code>.
         */
        public boolean isInconsistent() {
            return state == INCONSISTENT;
        }

        @Override
        public String toString() {
            String cls = this.getClass().getSimpleName();
            if (isNotChanged())
                return cls + ": NOT CHANGED";
            if (isInconsistent())
                return cls + ": INCONSISTENT";
            return cls + ": ERROR";
        }
    }
    /**
     * This class implements the possible state for a semantic writing process.
     * <p>
     * In particular, this class extend {@link MappingState} by adding to more states:
     * {@link #ADDED} and {@link #UPDATED}. <br>
     *
     * <p>Thus, possible states for a {@link Semantics#writeSemantics()} and
     * {@link IndividualDescriptor.SemanticMap.Resources#writeSemantics(IndividualDescriptor.DataDescriptor)} processes are:<ul>
     *    <li> {@link #ERROR}: implemented in {@link MappingState},
     *    <li> {@link #INCONSISTENT}: implemented in {@link MappingState},
     *    <li> {@link #NOT_CHANGED}: implemented in {@link MappingState},
     *    <li> <b>ADD</b>: the writing operation produced something new in the semantic description,
     *    <li> <b>UPDATE</b>: the writing operation changed the semantic of something.
     * </ul>
     *
     * <p>
     * <b>REMARK</b>: extending classes must have static state fields
     * assigned to inter values bigger than {@link #UPDATED}.
     *
     * <div style="text-align:center;"><small>
     * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
     * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
     * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
     * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
     * <b>date</b>:       06/01/2017 <br>
     * </small></div>
     *
     * @see MappingState
     * @see TryingWrite
     */
    class WritingState extends MappingState {
        // enum restarts from MappingState
        /** The identifier for the ADDED state. */
        static public final int ADDED = 2; // something was added
        /** The identifier for the UPDATED state. */
        static public final int UPDATED = 3; // something was updated

        static public final int REMOVED = 4;

        /** Empty Constructor, calls {@link MappingState#MappingState()} */
        public WritingState() {
            super();
        }

        /**
         * Constructs this object with a given state.<br>
         * The input parameter must be:
         * <code> {@link #state} &gt;= {@link #ERROR} &amp; {@link #state} &lt;= {@link #UPDATED} </code>.
         * Otherwise, the {@link #state} will be set based on {@link Semantics.MappingState#MappingState()}.
         * @param state the outcome of a semantic writing operation.
         */
        public WritingState(int state) {
            super();
            if (state >= ERROR & state <= REMOVED)
                this.state = state;
        }

        /**
         * set this state as {@link #ADDED}
         * @return <code>'this'</code>, for chaining calls.
         */
        public WritingState asAdded() {
            this.state = ADDED;
            return this;
        }

        /**
         * set this state as {@link #UPDATED}
         * @return <code>'this'</code>, for chaining calls.
         */
        public WritingState asUpdated() {
            this.state = UPDATED;
            return this;
        }

        public WritingState asRemoved() {
            this.state = REMOVED;
            return this;
        }

        @Override
        public WritingState asError() {
            return (WritingState) super.asError();
        }

        @Override
        public WritingState asNotChanged() {
            return (WritingState) super.asNotChanged();
        }

        @Override
        public WritingState asInconsistent() {
            return (WritingState) super.asInconsistent();
        }

        /**
         * @return <code>true</code> if the writing operation adds something in the semantics.
         * Namely, <code>return {@link #state} == {@link #ADDED}</code>.
         */
        public boolean isAdded() {
            return state == ADDED;
        }

        /**
         * @return <code>true</code> if this operation change the semantic of something.
         * Namely, <code>return {@link #state} == {@link #UPDATED}</code>.
         */
        public boolean isUpdated() {
            return state == UPDATED;
        }

        public boolean isRemoved() {
            return state == REMOVED;
        }

        @Override
        public String toString() {
            String cls = this.getClass().getSimpleName();
            if (isNotChanged())
                return cls + ": NOT CHANGED";
            if (isAdded())
                return cls + ": ADDED";
            if (isUpdated())
                return cls + ": UPDATED";
            if (isInconsistent())
                return cls + ": INCONSISTENT";
            if (isRemoved())
                return cls + ": REMOVED";
            return cls + ": ERROR";
        }

        /**
         * Merges an input state with this state and return a combined feasible state.<br>
         * It is based on {@link Semantics.WritingState#combineResults( Semantics.WritingState, Semantics.WritingState)}
         * with <code>'this'</code> and <code>'otherResult</code> as input
         * parameter respectively.
         * @param otherResult the state to be merged with <code>'this'</code>.
         * @return a new state that comes from the combination of <code>'this'</code>
         * and the input parameter.
         */
        public WritingState merge(WritingState otherResult) {
            return combineResults(this, otherResult);
        }
        /**
         * Merges two writings states and generates an output feasible state.
         * <p>In particular, it returns:<ul>
         *    <li> {@link #INCONSISTENT}: if at lest one state is in inconsistent state,
         *    <li> {@link #ERROR}: if at least one state is in error state,
         *    <li> {@link #NOT_CHANGED}: if both did not change nothing.
         *                          If only one input parameter is in {@link #NOT_CHANGED} state, it returns the other.
         *    <li> {@link #UPDATED}:  if both update something in the semantics.
         *                          If only one input parameter is in {@link #UPDATED} state, it returns the other.
         *    <li> {@link #ADDED}: if is not one of the case above.
         * </ul><p>
         * @param r1 the first writing state to merge.
         * @param r2 the second writing state to merge.
         * @return a new writing state obtained from the combination of the input parameters.
         */
        public static WritingState combineResults(WritingState r1, WritingState r2) {
            // todo check for REMOVED

            // high priority for inconsistent
            if (r1.isInconsistent() | r2.isInconsistent())
                return new WritingState().asInconsistent(); // INCONSISTENT

            // quite high priority for errors
            if (r1.isError() | r2.isError())
                return new WritingState().asError(); // ERROR

            // set as not changed if both did not change
            if (r1.isNotChanged() & r2.isNotChanged())
                return new WritingState().asNotChanged(); // NOT CHANGED
            else { // otherwise return the other
                if (r1.isNotChanged())
                    return r2;
                if (r2.isNotChanged())
                    return r1;
            }

            // set as update if both have been updated
            if (r1.isUpdated() & r2.isUpdated())
                return new WritingState().asUpdated(); // UPDATED
            else { // otherwise return the other
                if (r1.isNotChanged())
                    return r2;
                if (r2.isNotChanged())
                    return r1;
            }

            // set as added for the other case (added v.s. {not changed, updated, added})
            return new WritingState().asAdded(); // ADDED
        }

    }
    /**
     * This class implements the possible state for a semantic reading process.
     * <p>
     * In particular, this class manages the base state types (see {@link MappingState})
     * and writing state states:
     *
     * More in details, this class extend {@link MappingState} by adding to more states:
     * {@link #ABSENT} and {@link #SUCCESS}. <br>
     * <p>Thus, possible states for a {@link Semantics#readSemantics()}
     *   {@link IndividualDescriptor.SemanticMap.Resources#readSemantics(IndividualDescriptor.DataDescriptor)} processes are:<ul>
     *    <li> {@link #ERROR}: implemented in {@link MappingState},
     *    <li> {@link #INCONSISTENT}: implemented in {@link MappingState},
     *    <li> {@link #NOT_CHANGED}: implemented in {@link MappingState},
     *    <li> <b>ABSENT</b>: reading failure, since not data were available in the semantic description,
     *    <li> <b>SUCCESS</b>: reading success, java representation has been up to dated.
     * </ul>
     *
     * <p>
     * <b>REMARK</b>: extending classes must have static state fields
     * assigned to inter values bigger than {@link #SUCCESS}.
     *
     * <div style="text-align:center;"><small>
     * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
     * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
     * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
     * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
     * <b>date</b>:       06/01/2017 <br>
     * </small></div>
     *
     * @see MappingState
     * @see ReadingOutcome
     * @see TryingRead
     */
    class ReadingState extends MappingState {
        // enum restarts from MappingState
        /** The identifier for the ABSENT state. */
        static public final int ABSENT = 2; // not found in the ontology
        /** The identifier for the SUCCESS state. */
        static public final int SUCCESS = 3; // fond and read

        /** Empty Constructor, calls {@link MappingState#MappingState()} */
        public ReadingState() {
            super();
        }

        /**
         * Constructs this object with a given state.<br>
         * The input parameter must be:
         * <code> {@link #state} &gt;= {@link #ERROR} &amp; {@link #state} &lt;= {@link #SUCCESS} </code>.
         * Otherwise, the {@link #state} will be set based on {@link MappingState#MappingState()}.
         * @param state the outcome of a semantic reading operation.
         */
        public ReadingState(int state) {
            super();
            if (state >= ERROR | state <= SUCCESS)
                this.state = state;
        }

        /**
         * set this state as {@link #ABSENT}
         * @return <code>'this'</code>, for chaining calls.
         */
        public ReadingState asAbsent() {
            this.state = ABSENT;
            return this;
        }

        /**
         * set this state as {@link #SUCCESS}
         * @return <code>'this'</code>, for chaining calls.
         */
        public ReadingState asSuccess() {
            this.state = SUCCESS;
            return this;
        }

        @Override
        public ReadingState asError() {
            return (ReadingState) super.asError();
        }

        @Override
        public ReadingState asNotChanged() {
            return (ReadingState) super.asNotChanged();
        }

        @Override
        public ReadingState asInconsistent() {
            return (ReadingState) super.asInconsistent();
        }

        /**
         * @return <code>true</code> if the readings fails since the no data has been found.
         * Namely, <code>return {@link #state} == {@link #ABSENT}</code>.
         */
        public boolean isAbsent() {
            return state == ABSENT;
        }

        /**
         * @return <code>true</code> if the read operation was successes and
         * java representation has been up to dated.
         * Namely, <code>return {@link #state} == {@link #SUCCESS}</code>.
         */
        public boolean isSuccess() {
            return state == SUCCESS;
        }

        @Override
        public String toString() {
            String cls = this.getClass().getSimpleName();
            if (isNotChanged())
                return cls + ": NOT CHANGED";
            if (isSuccess())
                return cls + ": SUCCESS";
            if (isAbsent())
                return cls + ": ABSENT";
            if (isInconsistent())
                return cls + ": INCONSISTENT";
            return cls + ": ERROR";
        }

        /**
         * Merges an input state with this state and return a combined feasible state.<br>
         * It is based on {@link Semantics.ReadingState#combineResults( Semantics.ReadingState, Semantics.ReadingState)}
         * with <code>'this'</code> and <code>'otherResult</code> as input
         * parameter respectively.
         * @param otherResult the state to be merged with <code>'this'</code>.
         * @return a new state that comes from the combination of <code>'this'</code>
         * and the input parameter.
         */
        public ReadingState merge(ReadingState otherResult) {
            return combineResults(this, otherResult);
        }
        /**
         * Merges an input state with this state and return a combined feasible state.<br>
         * It is based on {@link Semantics.ReadingState#combineResults( Semantics.ReadingState, Semantics.ReadingState)}
         * with <code>'this'</code> and <code>'otherResult</code> as input
         * parameter respectively.
         * @param otherResult the reading outcome from which retrieve the state to be merged with <code>'this'</code>.
         * @return a new state that comes from the combination of <code>'this'</code>
         * and the input parameter.
         */
        public ReadingState merge( ReadingOutcome otherResult) {
            return combineResults(this, otherResult.getState());
        }
        /**
         * Merges two reading states and generates an output feasible state.
         * <p>In particular, it returns:<ul>
         *    <li> {@link #INCONSISTENT}: if at lest one state is in inconsistent state,
         *    <li> {@link #ERROR}: if at least one state is in error state,
         *    <li> {@link #NOT_CHANGED}: if both did not change nothing.
         *                          If only one input parameter is in {@link #NOT_CHANGED} state, it returns the other.
         *    <li> {@link #ABSENT}:  if at least one state is in absent state,
         *    <li> {@link #SUCCESS}: if is not one of the case above.
         * </ul>
         * @param r1 the first reading state to merge.
         * @param r2 the second reading state to merge.
         * @return a new reading state obtained from the combination of the input parameters.
         */
        public static ReadingState combineResults(ReadingState r1, ReadingState r2) {
            // high priority for inconsistent
            if (r1.isInconsistent() | r2.isInconsistent())
                return new ReadingState().asInconsistent(); // INCONSISTENT

            // quite high priority for errors
            if (r1.isError() | r2.isError())
                return new ReadingState().asError(); // ERROR

            // set as not changed if both did not change
            if (r1.isNotChanged() & r2.isNotChanged())
                return new ReadingState().asNotChanged(); // NOT CHANGED
            else { // otherwise return the other
                if (r1.isNotChanged())
                    return r2;
                if (r2.isNotChanged())
                    return r1;
            }

            // quite high priority for absents
            if (r1.isAbsent() | r2.isAbsent())
                return new ReadingState().asAbsent(); // ABSENT

            // set as success for the other case (success v.s. success})
            return new ReadingState().asSuccess(); // SUCCESS
        }
    }
    /**
     * A container for reading results.
     * <p>In particular, it contains:<ul>
     *    <li> the read buffer (of generic type <code>'T'</code>) for accessing data,
     *    <li> the {@link ReadingState}, describing the state associated to the buffer.
     * </ul>
     *
     * <div style="text-align:center;"><small>
     * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
     * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
     * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
     * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
     * <b>date</b>:       06/01/2017 <br>
     * </small></div>
     *
     * @param <T> the type of the read buffer.
     *
     * @see Semantics
     * @see ReadingState
     */
    class ReadingOutcome<T>{
        private T readBuffer; // the data read from the semantics
        private ReadingState state; // the state of the read buffer

        /**
         * Empty constructor initialises the {@link #readBuffer} to <code>null</code>
         * and the {@link MappingState#state} to {@link Semantics.ReadingState#ReadingState()}.
         */
        public ReadingOutcome(){
            readBuffer = null;
            state = new ReadingState();
        }

        /**
         * Initialise all fields of this container.
         * @param readBuffer the read buffer for accessing data,
         * @param state the state of the buffer.
         */
        public ReadingOutcome(T readBuffer, ReadingState state) {
            this.readBuffer = readBuffer;
            this.state = state;
        }

        /** @return the data in the reading buffer. */
        public T getReadBuffer() {
            return readBuffer;
        }

        /** @return the state associated to the reading buffer (see {@link #getReadBuffer}). */
        public ReadingState getState() {
            return state;
        }

        /**
         * An helper function that simply calls: <code>{@link #getState()}.{@link ReadingState#isOK()}</code>.
         * @return if the state of this reading process {@link ReadingState#isOK()}.
         */
        public boolean isOK(){
            return state.isOK();
        }
        /**
         * An helper function that simply calls: <code>{@link #getState()}.{@link ReadingState#isError()}</code>.
         * @return if the state of this reading process {@link ReadingState#isError()}.
         */
        public boolean isError(){
            return state.isError();
        }
        /**
         * An helper function that simply calls: <code>{@link #getState()}.{@link ReadingState#isInconsistent()}</code>.
         * @return if the state of this reading process {@link ReadingState#isInconsistent()}.
         */
        public boolean isInconsistent(){
            return state.isInconsistent();
        }
        /**
         * An helper function that simply calls: <code>{@link #getState()}.{@link ReadingState#isNotChanged()}</code>.
         * @return if the state of this reading process {@link ReadingState#isNotChanged()}.
         */
        public boolean isNotChanged(){
            return state.isNotChanged();
        }
        /**
         * An helper function that simply calls: <code>{@link #getState()}.{@link ReadingState#isAbsent()}</code>.
         * @return if the state of this reading process {@link ReadingState#isAbsent()}.
         */
        public boolean isAbsent(){
            return state.isAbsent();
        }
        /**
         * An helper function that simply calls: <code>{@link #getState()}.{@link ReadingState#isSuccess()}</code>.
         * @return if the state of this reading process {@link ReadingState#isSuccess()}.
         */
        public boolean isSuccess(){
            return state.isSuccess();
        }

        /**
         * Initialiser to be used for objects created through {@link #ReadingOutcome()}.
         * @param readBuffer the reading buffer, containing the data, to set.
         * @param state the state of the reading buffer.
         */
        public void setReadBuffer( T readBuffer, ReadingState state) {
            this.readBuffer = readBuffer;
            this.state = state;
        }

        /**
         * Merge the state for this reading operation with other
         * based on {@link ReadingState#merge( Semantics.ReadingState)}.
         * @param otherResult the state of a reading operation to merge with <code>'this'</code>.
         * @return <code>'this'</code> for chaining calls.
         */
        public ReadingOutcome merge(ReadingState otherResult){
            this.state.merge( otherResult);
            return this;
        }

        /**
         * Merge the state for this reading operation with other
         * based on {@link ReadingState#merge( Semantics.ReadingState)}}.
         * @param readingOutcome the reding outcome containing the state
         *                       of a reading operation to merge with <code>'this'</code>.
         * @return <code>'this'</code> for chaining calls.
         */
        public ReadingOutcome merge(ReadingOutcome readingOutcome){
            this.merge( readingOutcome.getState());
            return this;
        }

        @Override
        public String toString() {
            return "ReadingOutcome{" +
                    "readBuffer=" + readBuffer +
                    ", state=" + state +
                    '}';
        }
    }

    /**
     * This interface represents the class that should be able to manage
     * a specific semantic description ( e.g.: XML, OWL, MongoDB etc...).
     * <p>
     * It is supposed to be available in each {@link ObjectSemantics.Primitive} derived objects
     * through the {@link ObjectSemantics.Primitive#getSemantics()} method. <br>
     * This object is the one that can manipulate the ontology and try
     * to synchronise the java to the semantic representation;
     * <b>writing</b> process. As well as, perfroming <b>reading</b>
     * processes, to synchronise the semantic with the java representation.
     * <p>
     * In particular, this interface defines that a semantic description
     * should container a reference to the ontology in which semantically
     * map an object and the name of the instance that represent such an object.
     * A good practice is to set this name as the object unique identifier
     * (see {@link ObjectSemantics.Primitive#getID()}).
     *
     * <div style="text-align:center;"><small>
     * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
     * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
     * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
     * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
     * <b>date</b>:       06/01/2017 <br>
     * </small></div>
     *
     * @param <O> the class to refer to for manipulating the semantic structure.
     * @param <I> the individual describing an Object in the ontology.
     *
     * @see Semantics
     * @see ObjectSemantics.Primitive
     * @see IndividualDescriptor.Array3D
     */
    interface Descriptor<O,I> {
        /**
         * @return the class to refer to for manipulating the semantic structure.
         */
        O getOntology();

        /**
         * @return the individual that will describe a particular object in the ontology.
         */
        I getInstance(); // individual

        void setOntology( O ontology);
        void setInstance( I instance);
    }

    interface IndividualDescriptor<O,I,C,PD,PO,L> extends Descriptor<O,I> {

        String DEFAULT_DEBUGGING_MSG = "'??'";

        List<C> getTypes(); // todo to comment !!!!!!!!!!!!!!!!!!!!!!!!!   seee  getHighestType();

        // should internally map the type set ( <C> e.g.:OWLClass) to be related with this individual
        WritingState writeType(String debug);
        ReadingOutcome readType(String debug);
        default WritingState writeType(){
            return writeType( DEFAULT_DEBUGGING_MSG);
        }
        default ReadingOutcome readType(){
            return readType( DEFAULT_DEBUGGING_MSG);
        }

        // delegates to Primitive extension the definition of the value of the javaValue (e.g.: multi data property)
        WritingState writeLiteral(String debug, PD property, L javaValue);
        ReadingOutcome readLiteral(String debug, PD property, L oldJavaValue);
        default WritingState writeLiteral(PD property, L javaValue){
            return writeLiteral( DEFAULT_DEBUGGING_MSG, property, javaValue);
        }
        default ReadingOutcome readLiteral(PD property, L oldJavaValue){
            return readLiteral( DEFAULT_DEBUGGING_MSG, property, oldJavaValue);
        }

        // delegates to Primitive extension the definition of the value of the literal (e.g.: multi object property)
        WritingState writeProperty(String debug, PO property, I javaValue); // replace
        ReadingOutcome readProperty(String debug, PO property, I oldJavaValue); // replace
        default WritingState writeProperty(PO property, I javaValue){
            return writeProperty( DEFAULT_DEBUGGING_MSG, property, javaValue);
        }
        default ReadingOutcome readProperty(PO property, I oldJavaValue){
            return readProperty( DEFAULT_DEBUGGING_MSG, property, oldJavaValue);
        }


        /**
         * It should call the proper copy constructor.
         * @return a <code>new</code> copy of this object.
         */
        IndividualDescriptor<O,I,C,PD,PO,L> copy();

        /**
         * The generic interface to define the mapping of a 3D array in a semantic structure.
         * <p>
         *     It is based on reading and writing operations defined in the {@link Semantics} class,
         *     in turn based on {@link IndividualDescriptor.DataDescriptor}.<br>
         *     Moreover, it implements also the {@link Resources} base interface for specifying
         *     the specific semantic of a 3D array to be mapped from this class.
         *
         * <div style="text-align:center;"><small>
         * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
         * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
         * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
         * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
         * <b>date</b>:       06/01/2017 <br>
         * </small></div>
         *
         * @param <D> the class to refer to, for manipulating the semantic structure.
         *           It must extends: {@link IndividualDescriptor}.
         *
         * @see IndividualDescriptor
         * @see WritingState
         * @see ReadingState
         * @see ReadingOutcome
         */
        interface SemanticMap<D extends IndividualDescriptor> {

            /**
             * Map this 3D array to the semantic structure.
             * @param semantic the object that can manipulate the ontology
             *                 and try to synchronise the java representation
             *                 with the semantic structure.
             * @return the state of the writing process.
             */
            WritingState writeSemantics(final D semantic);

            /**
             * Map this 3D array from the semantic structure.
             * @param semantic the object that can manipulate the ontology
             *                 and try to synchronise the semantic structure
             *                 with the java representation.
             * @return the state of the reading process.
             */
            ReadingState readSemantics(final D semantic);

            /**
             * The base interface for specifying the specific semantic
             * of a 3D array to be mapped from the {@link SemanticMap}.
             * <p>
             *    It describes three properties of type
             *    <code>'T'</code> (e.g.: OWL data properties)
             *    where each of them map an Array component: <code>X, Y, Z</code>.
             *    Moreover, it defines method for checking if such property
             *    exists. This is done to set it with default values later,
             *    if not given by the user.
             *
             * <div style="text-align:center;"><small>
             * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
             * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
             * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
             * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
             * <b>date</b>:       06/01/2017 <br>
             * </small></div>
             *
             * @param <D> the class to refer to, for manipulating the semantic structure.
             *           It must extends: {@link IndividualDescriptor.DataDescriptor}.
             * @param <T> the type of the semantic property that map a single
             *           component of the array.
             *
             * @see IndividualDescriptor
             * @see SemanticMap
             * @see Array3D
             * @see MOR3DArray
             */
            interface Resources<D extends IndividualDescriptor, T> extends SemanticMap<D> {
                void setXproperty(final T xProperty, final D semantic);
                void setYproperty(final T yProperty, final D semantic);
                void setZproperty(final T zProperty, final D semantic);

                boolean hasXproperty();
                boolean hasYproperty();
                boolean hasZproperty();
            }
        }

        /**
         * Represents an easy ontological mapping structure of a spatial 3D array.
         * <p>
         *     In particular, it describes 3 components (i.e.: <code>X, Y, Z</code>)
         *     and a debugging textual description.<br>
         *     Moreover, this file contains the generic interface to define
         *     the {@link Semantics} of such a representation.
         *
         * <div style="text-align:center;"><small>
         * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
         * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
         * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
         * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
         * <b>date</b>:       06/01/2017 <br>
         * </small></div>
         *
         * @see SemanticMap
         * @see Semantics
         * @see IndividualDescriptor.DataDescriptor
         * @see SITBase
         */
        abstract class Array3D extends SITBase { // abstract not strictly reqiored

            /** the default value for the description field (empty) */
            public static final String DEFAULT_DESCRIPTION = "";
            // the local field of this data structure
            private Double x, y, z; // elements of the 3D array
            private String description; // debugging textual description

            /**
             * Cloning constructor, create a new object as a clone of the input parameter.
             * @param array the object to clone.
             */
            public Array3D( Array3D array){
                initialize( array.x, array.y, array.z, array.description);
            }
            /**
             * Construct with null values for all components (X,Y,Z)
             * and {@link #DEFAULT_DESCRIPTION}.
             */
            public Array3D(){
                initialize( null, null, null, DEFAULT_DESCRIPTION);
            }
            /**
             * Construct with null values for all components (X,Y,Z) and specified description.
             * @param description a comment used in {@link #toString()} method for debugging purposes.
             */
            public Array3D(String description){
                initialize( null, null, null, description);
            }
            /**
             * Construct by filling the components value, description set to {@link #DEFAULT_DESCRIPTION}.
             * @param x the value of the X component.
             * @param y the value of the Y component.
             * @param z the value of the Z component.
             */
            public Array3D(double x, double y, double z){
                initialize( x, y, z, DEFAULT_DESCRIPTION);
            }
            /**
             * Construct by filling the Components and description values.
             * @param x the value of the X component.
             * @param y the value of the Y component.
             * @param z the value of the Z component.
             * @param description a comment used in {@link #toString()} for debugging purposes.
             */
            public Array3D(double x, double y, double z, String description){
                initialize( x, y, z, description);
            }
            // common for all constructors
            private void initialize( Double x, Double y, Double z, String description){
                this.x = x;
                this.y = y;
                this.z = z;
                this.description = description;
            }

            /** @return the X value of this array, <code>null</code> if not set (@see {@link #Array3D()}). */
            public Double getX(){
                return x;
            }
            /** @return the Y value of this array, <code>null</code> if not set (@see {@link #Array3D()}).. */
            public Double getY(){
                return y;
            }
            /** @return the Z value of this array, <code>null</code> if not set (@see {@link #Array3D()}).. */
            public Double getZ(){
                return z;
            }

            /**
             * This method is mainly for logging purposes but gives also a clear interface for semantic based
             * Array3D (e.g.: {@link MOR3DArray}).
             * @param data the X, Y, Z, data to test.
             * @return <code>true if (data != null)</code> namely, if this object gets
             *         the related <code>data</code> initialised (see: {@link #Array3D()}).
             */
            protected boolean testGetter( Double data){
                if( data == null) {
                    //logWarning("[" + this.getClass().getSimpleName() + "] something is null!!! 0 returned as getX(), getY() or getZ() -> " + this);
                    return false;
                }
                return true;
            }

            /** @return false if at least one component (X, Y or Z) is null. True otherwise */
            public boolean checkData(){
                if( this.x == null || this.y == null || this.z == null)
                    return false;
                return true;
            }

            /** @return the description assign to this array for debugging */
            public String getDebuggingDescription(){
                return description;
            }

            /** @param x the value of the X component to set */
            public void setX( double x){
                this.x = x;
            }
            /** @param y the value of the Y component to set */
            public void setY( double y){
                this.y = y;
            }
            /** @param z the value of the Z component to set */
            public void setZ( double z){
                this.z = z;
            }
            /**
             * Helper that calls {@link #setX(double)}, {@link #setY(double)} and {@link #setZ(double)}.
             * @param x the value of the X component to set.
             * @param y the value of the Y component to set.
             * @param z the value of the Z component to set.
             */
            public void setXYZ( double x, double y, double z){
                setX( x);
                setY( y);
                setZ( z);
            }

            /**
             * Update this representation by averaging all its components
             * with the respective components of the input parameter.
             * @param array the X, Y and Z components to be merged with this representation.
             * @return <code>false</code> if an element of <code>this</code> or input array is <code>null</code>.
             * <code>True</code> otherwise.
             */
            public boolean average( Array3D array) {
                if( ! array.checkData())
                    return false;
                if( ! this.checkData())
                    return false;

                setX( ( getX() + array.getX()) / 2);
                setY( ( getY() + array.getY()) / 2);
                setZ( ( getZ() + array.getZ()) / 2);
                return true;
            }

            /** @param description the debugging string to set  */
            public void setDescirption( String description){
                this.description = description;
            }

            /**
             * It should call the proper copy constructor, not super class hierarchy.
             * @return a <code>new</code> copy of this object.
             */
            abstract public Array3D copy();

            /**
             * @return the textual information of this structure.
             * It prints the description field iff not equal to {@link #DEFAULT_DESCRIPTION}
             */
            @Override
            public String toString(){
                if( description.equals( DEFAULT_DESCRIPTION))
                    return "{" + x + ", " + y + ", " + z + "}";
                return description + ":{" + x + ", " + y + ", " + z + "}";
            }
        }
    }

    interface ClassDescriptor<O,C> extends Descriptor<O,C>{

        Set< C> getSuperInstances();
        Set< C> getSubInstances();

        WritingState writeSuperInstances();
        WritingState writeSubInstances();
        ReadingState readSuperInstances();
        ReadingState readSubInstances();
    }

    /**
     * This is an helper to manage {@link MappingState#ERROR} states for reading and writing operations.
     * <p>
     * It automatically catches for {@link java.lang.Exception} and manages {@link MappingState#ERROR}.
     *
     * <div style="text-align:center;"><small>
     * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
     * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
     * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
     * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
     * <b>date</b>:       06/01/2017 <br>
     * </small></div>
     *
     * @param <Y> the class that define the {@link MappingState}
     *           (i.e.: {@link ReadingState} or {@link WritingState}).
     *
     * @see MappingState
     * @see TryingWrite
     * @see TryingRead
     */
    abstract class Try<Y> extends SITBase.SITBase {

        /** Empty constructor, does not do nothing */
        public Try() {
        }

        /**
         *  make your reading/writing to semantic operations safety from Java {@link Exception}
         *  @return the actual mapping state.
         */
        abstract protected Y giveAtry();

        /**
         * Called when a Java {@link Exception} occurs.
         * @return the generated {@link MappingState#ERROR} to be propagated.
         */
        abstract protected Y onError();

        /**
         * @return the state of this mapping operation. It can be the
         * {@link #giveAtry()} returning value or the {@link #onError()},
         * if Java {@link Exception} occurs (logged through {@link #logError(Exception)}).
         */
        public Y perform() { // todo: move this call to the constructor once
            try {
                return giveAtry();
            } catch (Exception e) {
                logError( e);
                return onError();
            }
        }
    }
    abstract class MappingTry<Y extends MappingState> extends Try< Y>{}
    /**
     * The {@link MappingTry} implementation for reading operations.
     *
     * <div style="text-align:center;"><small>
     * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
     * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
     * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
     * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
     * <b>date</b>:       06/01/2017 <br>
     * </small></div>
     *
     * @see MappingTry
     * @see ReadingState
     */
    abstract class TryingRead extends MappingTry<ReadingState> {
        @Override
        protected ReadingState onError() {
            return new ReadingState().asError();
        }
    }
    /**
     * The {@link MappingTry} implementation for writing operations.
     *
     * <div style="text-align:center;"><small>
     * <b>File</b>:       it.emarolab.scene_identification_tracking.semanticSceneLibrary.Semantics <br>
     * <b>Licence</b>:    GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007 <br>
     * <b>Author</b>:     Buoncompagni Luca (luca.buoncompagni@edu.unige.it) <br>
     * <b>affiliation</b>: DIBRIS, EMAROLab, University of Genoa. <br>
     * <b>date</b>:       06/01/2017 <br>
     * </small></div>
     *
     * @see MappingTry
     * @see WritingState
     */
    abstract class TryingWrite extends MappingTry<WritingState> {
        @Override
        protected WritingState onError() {
            return new WritingState().asError();
        }
    }

}