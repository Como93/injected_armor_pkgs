package it.emarolab.scene_identification_tracking.semanticSceneLibrary.example;


import it.emarolab.amor.owlInterface.OWLReferences;
import it.emarolab.scene_identification_tracking.semanticSceneLibrary.Base;
import it.emarolab.scene_identification_tracking.semanticSceneLibrary.core.aMORDescriptor.MORSceneDescriptor;
import it.emarolab.scene_identification_tracking.semanticSceneLibrary.core.aMORDescriptor.MORSpatialDescriptor;
import it.emarolab.scene_identification_tracking.semanticSceneLibrary.core.aMORDescriptor.aMORObject.MORPrimitive;

import java.util.Collection;
import java.util.Set;

public class SpatialRelationshipsTest {

    /**
     * the name of the {@link it.emarolab.amor.owlInterface.OWLReferences} of the aMORObject
     * library addressing the ontology in which the objects of this example will be mapped.
     */
    public static final String ONTO_NAME = "ONTO_NAME";
    /**
     * the file path in which the ontology created by this example will be saved.
     */
    public static final String ONTO_FILE_SAVING_PATH = System.getProperty("user.dir")
            + "/resources/semantic-scene-library/example/SpatialRelationshipsTest.owl";
    /**
     * the file path of the empty ontology populated by this example.
     * <b>REMARK</b>: to not overwrite this ontology!
     */
    public static final String ONTO_FILE_LOADING_PATH = System.getProperty("user.dir")
            + "/resources/semantic-scene-library/Aboxes/empty-object_spatial-rules.owl";
    /**
     * the IRI path of the ontology generated by this example.
     */
    public static final String ONTO_IRI_PATH = "http://www.semanticweb.org/emaroLab/luca-buoncompagni/sit";
    /**
     * set to <code>false</code> to apply the ontological changes as soon as they are proposed.
     * If you set it to <code>true</code>, the semantic will be written to the ontology only
     * when {@link OWLReferences#applyOWLManipulatorChanges()} is called.
     */
    public static final boolean ONTO_BUFFERISE_CHANGES = true;

    public static void main(String[] args) throws InterruptedException {
        OWLReferences ontoRef = ObjectSemanticTest.addTestingObjects(
                ONTO_NAME, ONTO_FILE_LOADING_PATH, ONTO_IRI_PATH, ONTO_BUFFERISE_CHANGES, false, true);

        Base.Logger.showDebugs( true);
        Base.Logger.LOG( "\n\n");

        // disjointing do not need pre-reasoning
        // (semantic Geometric Primitive already of a given type)
        ontoRef.makeDisjointIndividuals( ontoRef.getIndividualB2Class( Base.CLASS.OBJECT));
        long t = System.nanoTime();
        ontoRef.synchronizeReasoner();
        double sec = (System.nanoTime() - t) / 1000000;
        Base.Logger.LOG( "**************** Reasoning: " + sec + "[ms]");

        // retrieve sphere object
        Set< MORPrimitive> allPrimitive = MORPrimitive.loadFromClass( ONTO_NAME);
        Base.Logger.LOG( MORPrimitive.readAllSemantics( allPrimitive));

        /* // Example for writing spatial properties
        for( MORPrimitive p : allPrimitive) {
            if ( p.getSemantics().getInstanceName().equals("0")) {
                MORSpatialDescriptor.MORSpatialRelation rel = new MORSpatialDescriptor.MORSpatialRelation
                        (ontoRef, p.getSemantics().getInstance(), p.getSemantics().getBottomType(), "hasSomething");
                rel.addItems("1", "Plane");
                rel.addItems("3", "Cylinder");
                p.getSemantics().linkInstance(rel);


                // use hierarchic typed descriptor to map also OWLClasses
                MORSpatialDescriptor.MORSpatialRelation rel1 = new MORSpatialDescriptor.MORSpatialRelation
                        (ontoRef, p.getSemantics().getInstance(), p.getSemantics().getBottomType(), "hasProp");
                rel1.setInverseProperty("hasInverseProp");
                rel1.addItems(ontoRef.getOWLIndividual("M"), ontoRef.getOWLClass("Mug"));
                rel1.addItems(ontoRef.getOWLIndividual("Y"), ontoRef.getOWLClass("Cone"));
                p.getSemantics().linkInstance(rel1);
            }
            Base.Logger.LOG("Writing semantic for " + p.getSemantics().getInstanceName() + " " + p.writeSemantic());
        }*/

        MORSpatialDescriptor.MORSpatialCollector relations = new MORSpatialDescriptor.MORSpatialCollector( ontoRef);
        for( MORPrimitive o : allPrimitive) {
            Collection<MORSpatialDescriptor.MORSpatialRelation> collection = o.getSemantics().getLinksMap().values();//.querySpatialProperties();
            for (MORSpatialDescriptor.MORSpatialRelation r : collection)
                relations.add( r);
            //collector.addAll( relations);
        }
        Base.Logger.LOG( "-------------------------------------------------------------------------");
        Base.Logger.LOG( "\nAll raw spatial relations that describe a scene:");
        Base.Logger.LOG( relations);
        Base.Logger.LOG( "-------------------------------------------------------------------------");
        Base.Logger.LOG( "\n\t* That can be cleaned:");
        relations.clean();
        Base.Logger.LOG( relations);
        Base.Logger.LOG( "-------------------------------------------------------------------------");
        Base.Logger.LOG( "\n\t\t** And that can be mapped into the scene representation:");
        Scene atoms = relations.getSceneAtoms();
        int cnt = 0;
        for( MORSceneDescriptor.MORSceneAtom a : atoms.getAtoms())
            Base.Logger.LOG( "\t-" + Base.Logger.padString( ++cnt + "", Base.LOGGING.LENGTH_NUMBER,true)
                    + ".\t\t" + a);
        Base.Logger.LOG( "\n\t\t\t*** which computes also the cardinality: " + atoms.getCardinality());
        Base.Logger.LOG( "-------------------------------------------------------------------------");

        // save ontology and inferred axioms to see reasingng effects
        ontoRef.saveOntology( ONTO_FILE_SAVING_PATH);
        Base.Logger.LOG( "\n\tontological representation saved on: " + ONTO_FILE_SAVING_PATH);

    }
}
